/*
Bankers Algorithm
*/
#include<stdio.h>
int main(){
	int process_count, resource_count,i ,j, k;
	
	printf("\nEnter process_count: ");
	scanf("%d",&process_count);
	
	printf("\nEnter resource_count: ");
	scanf("%d",&resource_count);
	
	int allocation[process_count][resource_count];
	int max[process_count][resource_count];
	int available[resource_count];
	int need[process_count][resource_count];
	
	printf("\nEnter allocation matrix: ");
	for(i=0;i<process_count;i++){
		for(j=0;j<resource_count;j++){
			scanf("%d",&allocation[i][j]);
		}
	}
	
	printf("\nEnter max matrix: ");
	for(i=0;i<process_count;i++){
		for(j=0;j<resource_count;j++){
			scanf("%d",&max[i][j]);
		}
	}
	
	printf("\nEnter available matrix: ");
	for(j=0;j<resource_count;j++){
		scanf("%d",&available[j]);
	}
	
	//Finding need matrix
	for(i=0;i<process_count;i++){
		for(j=0;j<resource_count;j++){
			need[i][j] = max[i][j] - allocation[i][j];
		}
	}
	
	//Checking if need<=allocation
	int flag=0, flag_arr[resource_count],counter=0;
	
	for(i=0;i<resource_count;i++){
		flag_arr[i] = -1;
	}
	
	printf("\nSafe state: \n");
	while(counter!=process_count){
		for(i=0;i<process_count;i++){
			for(j=0;j<resource_count;j++){
				if(need[i][j] > available[j]){
					flag=1;
					break;
				}
				flag=0;
			}
			if(flag==0 && flag_arr[i]!=1){
				for(k=0;k<resource_count;k++){
					available[k]+=allocation[i][k];
				}
				flag_arr[i] = 1;
				printf("P%d ",i);
				counter++;
			}
		}
	}
	return 0;
}

//RR
#include<stdio.h>

int main() {
    int n, x = 0, i, j, t;

    //Read the number of processes
    printf("Enter the number of process : ");
    scanf("%d", &n);

    int bta[n], bt[n], tat[n], wt[n], ct[n], a[n];

    //Read the burst time of the processes
    printf("Enter the Burst time of process : ");
    for (i = 0; i < n; i++)
        scanf("%d", &bt[i]);

    //Read the time slice
    printf("Enter the Time slice : ");
    scanf("%d", &t);

    //Calculate process number
    for (i = 0; i < n; i++)
        a[i] = i + 1;

    //Initialize completion time to 0
    for (i = 0; i < n; i++)
        ct[0] = 0;

    //Duplicate burst time
    for (i = 0; i < n; i++)
        bta[i] = bt[i];

    //Computation
    for (j = 0; j < n; j++) {
        for (i = 0; i < n; i++) {
	    //Burst time is more than time slice
	    if (bta[i] > t) {
                bta[i] = bta[i] - t;
                x = x + t;
                ct[i] = x;
            } else if (bta[i] == 0)
                continue;
            else if (bta[i] <= t) {
                x = x + bta[i];
                ct[i] = x;
                bta[i] = 0;
            }
        }
    }

    //Completion time is TAT
    for (i = 0; i < n; i++)
        tat[i] = ct[i];

    //Calculate Waiting time
    for (i = 0, j = 0; i < n; i++, j++)
        wt[i] = tat[i] - bt[j];

    //Display
    printf("\nProcess\tBT\tCT\tTAT\tWT");
    for (i = 0; i < n; i++) {
        printf("\nP%d\t%d\t%d\t%d\t%d", a[i], bt[i], ct[i], tat[i], wt[i]);
    }
    printf("\n");

    return 0;
}



//semaphore

#include<unistd.h>
#include<stdio.h>
#include<pthread.h>
#include<semaphore.h>
int buf[5],f,r;
sem_t mutex,full,empty;
void *produce(void *arg)
{
	int i;
	for(i=0;i<10;i++)
	 {
	  sem_wait(&empty);
	  sem_wait(&mutex);
	  printf("produced item is %d\n",i);
	  buf[(++r)%5]=i;
	  sleep(1);
	  sem_post(&mutex);
	  sem_post(&full);
	}
}
void *consume(void *arg)
{
	int item,i;
	for(i=0;i<10;i++)
	{
	 sem_wait(&full);
	 sem_wait(&mutex); 
	 item=buf[(++f)%5];
 	 printf("consumed item is %d\n",item);
 	 sleep(1);
 	 sem_post(&mutex);
 	 sem_post(&empty);
	}
}
int main()
{
	pthread_t tid1,tid2;
	sem_init(&mutex,0,1);
	sem_init(&full,0,0);
	sem_init(&empty,0,5);
	pthread_create(&tid1,NULL,produce,NULL);
	pthread_create(&tid2,NULL,consume,NULL);
	pthread_join(tid1,NULL);
	pthread_join(tid2,NULL);
	return 0;
}	


//shm 

#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<sys/shm.h>
#include<string.h>
int main()
{
int i;
void *shared_memory;
char buff[100];
int shmid;
shmid=shmget((key_t)2345, 1024, 0666|IPC_CREAT);
printf("Key of shared memory is %d\n",shmid);
shared_memory=shmat(shmid,NULL,0);
printf("Process attached at %p\n",shared_memory);
printf("Enter some data to write to shared memory\n");
read(0,buff,100);
strcpy(shared_memory,buff);
printf("You wrote : %s\n",(char *)shared_memory);
}


//shm2

#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<sys/shm.h>
#include<string.h>
int main()
{
int i;
void *shared_memory;
char buff[100];
int shmid;
shmid=shmget((key_t)2345, 1024, 0666);
printf("Key of shared memory is %d\n",shmid);
shared_memory=shmat(shmid,NULL,0);
printf("Process attached at %p\n",shared_memory);
printf("Data read from shared memory is : %s\n",(char *)shared_memory);
}


/*
disk fcfs
*/

#include<stdio.h>
#include<math.h>
int main(){
	int ready_queue_size,i,j;
	int initial_head_position,temp;
	int index,total_head_movement;

	
	printf("\nEnter the ready queue size: ");
	scanf("%d",&ready_queue_size);
	
	int readyqueue[ready_queue_size];
	
	printf("\nEnter the ready queue values: ");
	for(i=0;i<ready_queue_size;i++){
		scanf("%d", &readyqueue[i]);
	}
	
	printf("\nEnter the intial head position: ");
	scanf("%d",&initial_head_position);
	temp=initial_head_position;
	
	printf("\n");
	//printf("%d",initial_head_position);
	for(i=0;i<ready_queue_size;i++){
		printf(" %d-> ",readyqueue[i]);

		total_head_movement+= abs(readyqueue[i] - temp);//this holds present readyqueue value
		temp=readyqueue[i]; //staores pervious value
	}
	
	printf("\nTotal head movement: %d",total_head_movement);

	
	return 0;
}




/*
SCAN Algorithm in disk scheduling.
*/
#include<stdio.h>
#include<math.h>//for abs()
int main(){
	int track_size, initial_head_position,i,j;
	int total_head_movement,temp,initial_index;
	int track_queue_size;
	
	printf("\nEnter the track size: ");
	scanf("%d",&track_size);
	
	printf("\nEnter the track queue size: ");
	scanf("%d",&track_queue_size);
	
	int track_queue[track_queue_size];
	
	printf("\nEnter the track queue: ");
	for(i=0;i<track_queue_size;i++){
		scanf("%d",&track_queue[i]);
	}
	
	printf("\nEnter the initial head position: ");
	scanf("%d",&initial_head_position);
	
	//sorting the track queue in ascending order
	for(i=0;i<track_queue_size;i++){
		for(j=0;j<track_queue_size-i-1;j++){
			if(track_queue[j]>track_queue[j+1]){
				temp= track_queue[j];
				track_queue[j] = track_queue[j+1];
				track_queue[j+1] = temp;
			}
		}
	}
	
	//finding the index position of initial head in track queue
	for(i=0;i<track_queue_size;i++){
		if(initial_head_position < track_queue[i]){
			initial_index = i;
			break;
		}
	}
	printf("\nInitial head index pos =%d",initial_index);
	
	//moving from the initial_index to far right
	printf("\n\nMoving from initial head pos to far right..");
	printf("%d",initial_head_position);
	for(i=initial_index;i<track_queue_size;i++){
		printf(" -> %d", track_queue[i]);
	}
	
	
	total_head_movement+= abs(track_size-1 - initial_head_position); //199-50
	printf("tdm= %d",total_head_movement);
	//update initial head position
	initial_head_position = track_size-1;
	printf(" -> %d",initial_head_position);
	
	
	//moving from the initial head to far left
	printf("\nMoving from current head pos. to far left..");
	for(i=initial_index-1;i>=0;i--){
		printf(" -> %d", track_queue[i]);
	}
	
	total_head_movement+= abs(track_size-1 - track_queue[i+1]); //i+1 because i-- causes i to gobelow 0
	//199-16
	
	printf("\n\nTotal head movements= %d",total_head_movement);
	
	return 0;
}

/*
disk cscan
*/

#include<stdio.h>
#include<math.h>
int main(){
	int track_size,ready_queue_size,i,j;
	int initial_head_position,temp;
	int index,total_head_movement;
	
	printf("\nEnter the track size: ");
	scanf("%d",&track_size);
	
	printf("\nEnter the ready queue size: ");
	scanf("%d",&ready_queue_size);
	
	int readyqueue[ready_queue_size];
	
	printf("\nEnter the ready queue values: ");
	for(i=0;i<ready_queue_size;i++){
		scanf("%d", &readyqueue[i]);
	}
	
	printf("\nEnter the intial head position: ");
	scanf("%d",&initial_head_position);
	
	//sorting the ready queue
	for(i=0;i<ready_queue_size;i++){
		for(j=0;j<ready_queue_size-i-1;j++){
			if(readyqueue[j]>readyqueue[j+1]){
				temp = readyqueue[j];
				readyqueue[j] = readyqueue[j+1];
				readyqueue[j+1] = temp;
			}
		}
	}
	
	//find index position of initial head value in the sorted ready queue
	
	for(i=0;i<ready_queue_size;i++){
		if(initial_head_position<readyqueue[i]){
			index = i;
			break;
		}
	}
	
	//printing ready queue value while moving right
	printf("\n%d->",initial_head_position);
	for(i=index;i<ready_queue_size;i++){
		printf(" %d-> ",readyqueue[i]);
	}
	printf(" %d-> ",track_size-1);
	
	total_head_movement+= abs(track_size-1 - initial_head_position);

	total_head_movement+= abs(0 - (track_size-1));

	
	//take the head to 0 and process requests again to the right side[larger value side]
	printf(" 0-> ");
	for(i=0;i<index;i++){
		printf(" %d-> ",readyqueue[i]);
	}
	total_head_movement+= abs(0 -readyqueue[i-1]);
	
	printf("\nTotal head movement: %d",total_head_movement);

	
	return 0;
}

/*
memory first fit
*/

/*
First Fit allocation strategy - The approach is to allocate the first free partition or hole large enough which can accommodate the process.
*/
#include<stdio.h>
int main(){
	int i,j,memory_count, process_count;
	
	printf("\nEnter number of partitions: ");
	scanf("%d",&memory_count);
	
	printf("\nEnter number of processes: ");
	scanf("%d",&process_count);
	
	int memory[memory_count],process[process_count],answer[memory_count];
	
	printf("\nEnter the partitions: ");
	for(i=0;i<memory_count;i++){
		scanf("%d",&memory[i]);
	}
	
	printf("\nEnter the processes sizes: ");
	for(i=0;i<process_count;i++){
		scanf("%d",&process[i]);
	}
	
	//setting the answer array to -1
	for(i=0;i<memory_count;i++){
		answer[i]=-1;
	}
	
	for(i=0;i<process_count;i++){
		for(j=0;j<memory_count;j++){
			if(process[i]<memory[j] && answer[j]==-1){
				answer[j] = i;
				memory[j]-=process[i];
				break;
			}
		}
	}
	
	//displaying ans.
	printf("\n\nOutput:\n\n");
	for(i=0;i<memory_count;i++){
		if(answer[i]==-1){
			printf("  X  ");
		}
		else{
			printf("  %d  ",answer[i]);
		}
	}
	printf("\n");
	for(i=0;i<memory_count;i++){
		printf(" %d ", memory[i]);
	}
	return 0;
}

/*
memory best fit
*/


#include<stdio.h>
int main(){
	int i,j,memory_count, process_count;
	
	printf("\nEnter number of partitions: ");
	scanf("%d",&memory_count);
	
	printf("\nEnter number of processes: ");
	scanf("%d",&process_count);
	
	int memory[memory_count],process[process_count],answer[memory_count];
	
	printf("\nEnter the partitions: ");
	for(i=0;i<memory_count;i++){
		scanf("%d",&memory[i]);
	}
	
	printf("\nEnter the processes sizes: ");
	for(i=0;i<process_count;i++){
		scanf("%d",&process[i]);
	}
	
	//setting the answer array to -1
	for(i=0;i<memory_count;i++){
		answer[i]=-1;
	}
	
	int flag=0,temp,index;
	for(i=0;i<process_count;i++){
        for(j=0;j<memory_count;j++){
			if(memory[j]<process[i] || answer[j]!=-1){
				continue;
			}
			else if(memory[j]>process[i] && flag==0){
				temp=memory[j];
				index=j;
				flag=1;
				continue;
			}
			else if(flag==1 && memory[j]<temp && memory[j]>=process[i]){
				temp = memory[j];
				index=j;
			}
        }
		if(flag==1){
			flag=0;
			answer[index] = i;
			//upon getting a final answer decrement the memory
			memory[index]-= process[i];
		}
   }
  
	//displaying ans.
	printf("\n\nOutput:\n\n");
	for(i=0;i<memory_count;i++){
		if(answer[i]==-1){
			printf("  X  ");
		}
		else{
			printf("  %d  ",answer[i]);
		}
	}
	printf("\n");
	for(i=0;i<memory_count;i++){
		printf(" %d ", memory[i]);
	}
	return 0;
}
